


<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Neon Defense</title>

<style>
body {
margin: 0;
overflow: hidden;
background-color: #050505;
font-family: 'Courier New', Courier, monospace;
touch-action: none;
user-select: none;
}
canvas { display: block; }

/* SCROLLBAR STYLE */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: #111; }
::-webkit-scrollbar-thumb { background: #0ff; border-radius: 4px; }

#ui-layer {
position: absolute; top: 0; left: 0;
width: 100%; height: 100%;
pointer-events: none;
display: flex; flex-direction: column;
justify-content: space-between;
}

.hud-top {
display: flex; justify-content: space-between; align-items: flex-start;
padding: 10px;
}

.hud-panel {
padding: 10px 15px;
color: #0ff;
text-shadow: 0 0 5px #0ff;
font-weight: bold;
font-size: 16px;
background: rgba(0,0,0,0.8);
border-bottom-right-radius: 10px;
border-bottom-left-radius: 10px;
border: 1px solid #333;
border-top: none;
}

#btn-info {
pointer-events: auto;
background: #222;
border: 1px solid #0ff;
color: #0ff;
width: 30px; height: 30px;
border-radius: 50%;
text-align: center;
line-height: 28px;
font-weight: bold;
font-size: 18px;
cursor: pointer;
box-shadow: 0 0 10px #0ff;
margin-top: 5px;
}

#high-score-box { color: #ff0; font-size: 14px; margin-top: 5px; text-shadow: 0 0 5px #ff0; }

#controls-area {
pointer-events: auto;
background: rgba(0,0,0,0.9);
min-height: 90px;
display: flex;
justify-content: center;
align-items: center;
border-top: 1px solid #333;
}

/* BUILD MENU */
#build-menu { display: flex; gap: 8px; padding: 10px; flex-wrap: wrap; justify-content: center; }
.tower-btn {
background: rgba(0, 255, 255, 0.05);
border: 1px solid #444;
color: #ccc;
padding: 6px 8px;
font-size: 11px;
border-radius: 6px;
cursor: pointer;
text-align: center;
min-width: 65px;
transition: all 0.2s;
}
.tower-btn b { display: block; font-size: 13px; margin-bottom: 2px; }
.tower-btn.affordable {
border-color: #0ff; color: #0ff;
box-shadow: 0 0 5px rgba(0, 255, 255, 0.2);
background: rgba(0, 255, 255, 0.1);
}
.tower-btn.selected { background: #0ff; color: #000; box-shadow: 0 0 15px #0ff; }

/* UPGRADE MENU */
#upgrade-menu {
display: none; flex-direction: column; width: 100%; padding: 10px 20px; color: #fff;
}
.upgrade-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 5px; }
.live-stats { font-size: 14px; color: #aaa; margin-bottom: 5px; font-family: monospace; }
.live-val { color: #fff; font-weight: bold; }
.upgrade-actions { display: flex; gap: 15px; justify-content: center; }
.action-btn {
padding: 8px 15px; border-radius: 5px; border: 1px solid #fff;
background: rgba(255,255,255,0.1); color: #fff; cursor: pointer;
font-weight: bold; flex: 1; text-align: center;
}
.btn-upgrade { border-color: #0f0; color: #0f0; }
.btn-upgrade.disabled { border-color: #555; color: #555; background: transparent; }
.btn-close { border-color: #f00; color: #f00; max-width: 50px; }

/* INFO MODAL */
#info-modal {
display: none;
position: absolute; top: 50%; left: 50%;
transform: translate(-50%, -50%);
width: 90%; max-width: 600px; max-height: 80%;
background: rgba(10, 10, 10, 0.95);
border: 2px solid #0ff;
box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
z-index: 100;
padding: 20px;
overflow-y: auto;
pointer-events: auto;
color: #ddd;
}
#info-modal h2 { color: #0ff; border-bottom: 1px solid #333; padding-bottom: 10px; margin-top: 0; }
#info-modal h3 { color: #ff0; margin-top: 20px; margin-bottom: 5px; }
.info-close {
position: absolute; top: 10px; right: 10px;
color: #f00; border: 1px solid #f00; background: transparent;
font-size: 16px; cursor: pointer; padding: 5px 10px;
}
.info-table { width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 10px; }
.info-table th, .info-table td { border: 1px solid #444; padding: 8px; text-align: left; }
.info-table th { background: #222; color: #0ff; }
.blob-swatch { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 5px; }

#game-over {
position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
text-align: center; color: white; display: none; pointer-events: auto;
background: rgba(0,0,0,0.9); padding: 30px; border: 2px solid #f0f;
border-radius: 15px; box-shadow: 0 0 30px #f0f; z-index: 200;
}
h1 { margin: 0 0 20px 0; color: #f0f; }
#instruction {
position: absolute; top: 80px; width: 100%;
text-align: center; color: rgba(255,255,255,0.7);
font-size: 14px; pointer-events: none; display: none;
}
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="ui-layer">
<div class="hud-top">
<div class="hud-panel">
<div id="stats-money">Money: $150</div>
<div id="stats-lives" style="color: #f0f;">Lives: 10</div>
<div id="stats-wave">Wave: 1</div>
<div id="high-score-box">High Score: 0</div>
</div>
<div id="btn-info" onclick="toggleInfo()">i</div>
</div>

<div id="instruction">Tap map to set position</div>

<div id="controls-area">
<div id="build-menu">
<div id="btn-basic" class="tower-btn" onclick="selectTowerType('basic')">
<b>Turret</b>
$50
</div>
<div id="btn-sniper" class="tower-btn" onclick="selectTowerType('sniper')">
<b>Sniper</b>
$300
</div>
<div id="btn-tank" class="tower-btn" onclick="selectTowerType('tank')">
<b>Tank</b>
$750
</div>
<div id="btn-cannon" class="tower-btn" onclick="selectTowerType('cannon')">
<b>Cannon</b>
$1000
</div>
</div>

<div id="upgrade-menu">
<div class="upgrade-header">
<span id="upg-title">WEAPON (Lvl 1)</span>
<button class="action-btn btn-close" onclick="closeUpgradeMenu()">X</button>
</div>
<div class="live-stats">
Reload: <span id="upg-reload" class="live-val">0.0s</span>
</div>
<div class="upgrade-actions">
<button id="btn-do-upgrade" class="action-btn btn-upgrade" onclick="performUpgrade()">
UPGRADE<br><span id="upg-cost">$350</span>
</button>
</div>
</div>
</div>
</div>

<div id="info-modal">
<button class="info-close" onclick="toggleInfo()">X</button>
<h2>NEON DEFENSE: MANUAL</h2>
<p><strong>Made by Vewerty Ploik</strong></p>
<p>Defend your base from waves of blobs. Tap a weapon below, then tap the map to place it. Tap an existing weapon to upgrade it.</p>

<h3>UPDATE LOG</h3>

<ul style="font-size: 12px; color: #aaa;">
<li>Added <b>The Queen</b> (Tier 6 Enemy)</li>
<li>Added <b>Cannon</b> (High DMG Weapon)</li>
<li>Added Info Dashboard</li>
<li>Implemented High Score Save</li>
</ul>

<h3>ENEMY ENCYCLOPEDIA (NERDY STATS)</h3>
<table class="info-table">
<tr>
<th>Type</th>
<th>HP</th>
<th>Spd</th>
<th>Reward</th>
<th>Notes</th>
</tr>
<tr>
<td><span class="blob-swatch" style="background:#87CEFA"></span>Blue</td>
<td>50</td>
<td>1.0x</td>
<td>$15</td>
<td>Basic fodder.</td>
</tr>
<tr>
<td><span class="blob-swatch" style="background:#90EE90"></span>Green</td>
<td>100</td>
<td>1.0x</td>
<td>$25</td>
<td>Slightly tougher.</td>
</tr>
<tr>
<td><span class="blob-swatch" style="background:#FFB347"></span>Orange</td>
<td>180</td>
<td>1.0x</td>
<td>$40</td>
<td>Absorbs damage.</td>
</tr>
<tr>
<td><span class="blob-swatch" style="background:#444"></span>Black</td>
<td>250</td>
<td>1.0x</td>
<td>$60</td>
<td>Armored blob.</td>
</tr>
<tr>
<td><span class="blob-swatch" style="background:#FF4444"></span>Red</td>
<td>350</td>
<td>1.0x</td>
<td>$100</td>
<td>Elite unit.</td>
</tr>
<tr>
<td><span class="blob-swatch" style="background:#800080; border:1px solid yellow;"></span><b>QUEEN</b></td>
<td>500</td>
<td>0.8x</td>
<td>$200</td>
<td>Is cool. Fast for a boss.</td>
</tr>
</table>
<p style="font-size: 10px; color:#666;">*Enemy HP scales +10 per Wave. Speed scales slightly per wave.</p>

<h3>WEAPON SCHEMATICS</h3>
<table class="info-table">
<tr>
<th>Weapon</th>
<th>Dmg</th>
<th>Reload</th>
<th>DPS</th>
<th>Cost</th>
</tr>
<tr>
<td style="color:#0ff">Turret</td>
<td>8</td>
<td>1.0s</td>
<td>8.0</td>
<td>$50</td>
</tr>
<tr>
<td style="color:#ff0">Sniper</td>
<td>45</td>
<td>3.5s</td>
<td>12.9</td>
<td>$300</td>
</tr>
<tr>
<td style="color:#0f0">Tank</td>
<td>80</td>
<td>5.0s</td>
<td>16.0</td>
<td>$750</td>
</tr>
<tr>
<td style="color:#fff">Cannon</td>
<td>215</td>
<td>5.0s</td>
<td>43.0</td>
<td>$1000</td>
</tr>
</table>
</div>

<div id="game-over">
<h1>GAME OVER</h1>
<p id="final-score">Waves Survived: 0</p>
<p id="new-high-score" style="color:#ff0; display:none;">NEW HIGH SCORE!</p>
<button class="tower-btn affordable" onclick="resetGame()" style="font-size: 16px; padding: 10px 30px;">Try Again</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONFIGURATION (UPDATED STATS) ---
const TOWER_TYPES = {
basic: { 
name: "Turret", cost: 50, range: 120, damage: 8, cooldownFrames: 60, color: '#0ff', bulletSpeed: 8, maxLevel: 1 
},
sniper: { 
name: "Sniper", cost: 300, range: 400, damage: 45, cooldownFrames: 210, color: '#ff0', bulletSpeed: 15, maxLevel: 5 
},
tank: { 
name: "Tank", cost: 750, range: 140, damage: 80, cooldownFrames: 300, color: '#0f0', bulletSpeed: 6, maxLevel: 5 
},
cannon: {
name: "Cannon", cost: 1000, range: 160, damage: 215, cooldownFrames: 300, color: '#fff', bulletSpeed: 5, maxLevel: 5

}
};

const ENEMY_TIERS = [
{ name: "Blue", hp: 50, color: '#87CEFA', reward: 15 },
{ name: "Green", hp: 100, color: '#90EE90', reward: 25 },
{ name: "Orange", hp: 180, color: '#FFB347', reward: 40 },
{ name: "Black", hp: 250, color: '#444444', reward: 60 },
{ name: "Red", hp: 350, color: '#FF4444', reward: 100 },
{ name: "Queen", hp: 500, color: '#800080', reward: 200 } // The Queen
];

// --- GAME STATE ---
let width, height;
let frame = 0;
let money = 150;
let lives = 10;
let wave = 1;
let isGameOver = false;
let spawnTimer = 0;
let highScore = localStorage.getItem('neonDefenseHighScore') || 0;

// Interaction State
let selectedTowerType = null;
let pendingTower = null;
let selectedExistingTower = null;

let enemies = [];
let towers = [];
let projectiles = [];
let particles = [];
let waypoints = [];
let floatingTexts = [];

// --- RESIZE & PATH ---
function resize() {
width = window.innerWidth;
height = window.innerHeight;
canvas.width = width;
canvas.height = height;
generatePath();
}
window.addEventListener('resize', resize);

function generatePath() {
waypoints = [
{x: width * 0.1, y: 0},
{x: width * 0.1, y: height * 0.3},
{x: width * 0.4, y: height * 0.3},
{x: width * 0.4, y: height * 0.7},
{x: width * 0.8, y: height * 0.7},
{x: width * 0.8, y: height * 0.2},
{x: width * 0.6, y: height * 0.2},
{x: width * 0.6, y: height * 0.9},
{x: width * 0.9, y: height * 0.9},
{x: width * 0.9, y: height} 
];
}
resize();

// --- CLASSES ---

class Enemy {
constructor(tierIndex) {
this.wpIndex = 0;
this.x = waypoints[0].x;
this.y = waypoints[0].y;
this.tierIndex = tierIndex;
this.radius = 14 + (tierIndex * 2);

// Speed Calculation
let baseSpeed = 0.6 + (wave * 0.05);
if (tierIndex === 5) baseSpeed = 0.8; // UPDATED QUEEN SPEED


this.speed = baseSpeed;
let tier = ENEMY_TIERS[tierIndex];
this.maxHp = tier.hp + (wave * 10);
this.hp = this.maxHp;
this.color = tier.color;
this.reward = tier.reward;
}

update() {
let target = waypoints[this.wpIndex + 1];
if (!target) return;

let dx = target.x - this.x;
let dy = target.y - this.y;
let dist = Math.hypot(dx, dy);

if (dist < this.speed) {
this.x = target.x;
this.y = target.y;
this.wpIndex++;
if (this.wpIndex >= waypoints.length - 1) this.reachEnd();
} else {
this.x += (dx / dist) * this.speed;
this.y += (dy / dist) * this.speed;
}
}

draw() {
// Body
ctx.shadowBlur = 10;
ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
ctx.fill();

ctx.shadowBlur = 0; 
ctx.strokeStyle = '#fff';
ctx.lineWidth = 1;
ctx.stroke();

// Draw QUEEN CROWN
if (this.tierIndex === 5) {
ctx.fillStyle = '#FFD700'; // Gold
ctx.beginPath();
ctx.moveTo(this.x - 10, this.y - this.radius);
ctx.lineTo(this.x - 5, this.y - this.radius - 10);
ctx.lineTo(this.x, this.y - this.radius - 5);
ctx.lineTo(this.x + 5, this.y - this.radius - 10);
ctx.lineTo(this.x + 10, this.y - this.radius);
ctx.closePath();
ctx.fill();
ctx.stroke();
}

// HP Bar
const barW = 24;
ctx.fillStyle = '#333';
ctx.fillRect(this.x - barW/2, this.y - this.radius - 8, barW, 4);
ctx.fillStyle = this.hp < this.maxHp * 0.3 ? '#f00' : '#0f0';
ctx.fillRect(this.x - barW/2, this.y - this.radius - 8, barW * (this.hp / this.maxHp), 4);
}

takeDamage(amt) {
this.hp -= amt;
addFloatingText(amt, this.x, this.y - 20, '#fff');

if (this.hp <= 0) {
money += this.reward;
addFloatingText(`+$${this.reward}`, this.x, this.y, '#ff0');
createExplosion(this.x, this.y, this.color, 8);
updateUI();
return true; 
}
return false;
}

reachEnd() {
lives--;
createExplosion(this.x, this.y, '#f00', 10);
updateUI();
this.hp = 0; 
checkGameOver();
}
}

class Tower {
constructor(x, y, typeKey) {
this.x = x; this.y = y; this.typeKey = typeKey;

const base = TOWER_TYPES[typeKey];
this.stats = { ...base }; 

this.level = 1;
this.nextUpgradeCost = base.cost + 50; 
this.cooldown = 0;
this.angle = 0;
}

update() {
if (this.cooldown > 0) this.cooldown--;
let target = null;
let minDist = Infinity;
enemies.forEach(e => {
let dist = Math.hypot(e.x - this.x, e.y - this.y);
if (dist < this.stats.range && dist < minDist) {
minDist = dist;
target = e;
}
});

if (target) {
this.angle = Math.atan2(target.y - this.y, target.x - this.x);
if (this.cooldown <= 0) {
projectiles.push(new Projectile(this.x, this.y, target, this.stats.damage, this.stats.bulletSpeed, this.stats.color, this.typeKey));
this.cooldown = this.stats.cooldownFrames;
}
}
}

upgrade() {
if (this.level >= this.stats.maxLevel) return;
this.level++;
this.stats.cooldownFrames = Math.floor(this.stats.cooldownFrames * 0.8);
this.nextUpgradeCost += 50;
createExplosion(this.x, this.y, '#fff', 15);
addFloatingText("UPGRADED!", this.x, this.y - 30, '#0f0');
}

draw() {
if (selectedExistingTower === this) {
ctx.beginPath(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
ctx.setLineDash([4, 4]); ctx.arc(this.x, this.y, 25, 0, Math.PI*2); ctx.stroke();
ctx.setLineDash([]);
ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.2)';
ctx.arc(this.x, this.y, this.stats.range, 0, Math.PI*2); ctx.stroke();
}

Tower.drawVisuals(this.x, this.y, this.angle, this.typeKey, false);

if (this.level > 1) {
ctx.fillStyle = '#fff'; ctx.font = '10px Arial'; ctx.textAlign = 'center';
ctx.fillText(`Lv${this.level}`, this.x, this.y + 20);
}
}

static drawVisuals(x, y, angle, typeKey, isGhost) {
ctx.save();
ctx.translate(x, y);
if(isGhost) ctx.globalAlpha = 0.6;

let stats = TOWER_TYPES[typeKey];

// Base
if (typeKey === 'tank') {
ctx.fillStyle = '#2E8B57';
if(!isGhost) { ctx.shadowBlur = 10; ctx.shadowColor = '#0f0'; }
ctx.fillRect(-12, -12, 24, 24);
} else if (typeKey === 'cannon') {
ctx.fillStyle = '#444'; // Dark Grey base
if(!isGhost) { ctx.shadowBlur = 10; ctx.shadowColor = '#fff'; }
ctx.beginPath(); ctx.arc(0,0, 14, 0, Math.PI*2); ctx.fill();
} else {
ctx.fillStyle = '#222';
ctx.beginPath(); ctx.arc(0,0, 10, 0, Math.PI*2); ctx.fill();
}

ctx.rotate(angle);

// Turret/Barrel
if (typeKey === 'sniper') {
ctx.fillStyle = '#aaa'; ctx.fillRect(0, -2, 30, 4); 
ctx.fillStyle = stats.color; ctx.fillRect(-5, -5, 10, 10);
} else if (typeKey === 'tank') {
ctx.fillStyle = '#006400'; ctx.fillRect(0, -6, 22, 12);
ctx.beginPath(); ctx.arc(0,0, 9, 0, Math.PI*2); ctx.fill();
} else if (typeKey === 'cannon') {
ctx.fillStyle = '#111'; // Black Cannon
ctx.strokeStyle = '#666'; ctx.lineWidth = 1;
// Wide short barrel
ctx.fillRect(0, -8, 20, 16); 
ctx.strokeRect(0, -8, 20, 16);
ctx.beginPath(); ctx.arc(0,0, 10, 0, Math.PI*2); ctx.fill();
} else {
ctx.fillStyle = stats.color; ctx.fillRect(0, -4, 18, 8);
ctx.fillStyle = '#fff'; ctx.fillRect(-5, -5, 10, 10);
}

ctx.restore();
}
}

class Projectile {
constructor(x, y, target, damage, speed, color, typeKey) {
this.x = x; this.y = y; this.target = target;
this.damage = damage; this.speed = speed; this.color = color;
this.typeKey = typeKey;
this.active = true;
let angle = Math.atan2(target.y - y, target.x - x);
this.vx = Math.cos(angle) * this.speed;
this.vy = Math.sin(angle) * this.speed;
}
update() {
this.x += this.vx; this.y += this.vy;
if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) this.active = false;
let dist = Math.hypot(this.x - this.target.x, this.y - this.target.y);
if (dist < this.target.radius + 8 && this.active && this.target.hp > 0) {
this.target.takeDamage(this.damage);
this.active = false;
createExplosion(this.x, this.y, this.color, 4);
}
}
draw() {
ctx.shadowBlur = 5; ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath(); 

if (this.typeKey === 'cannon') {
// Cannonball
ctx.arc(this.x, this.y, 6, 0, Math.PI*2);
} else {
ctx.arc(this.x, this.y, 4, 0, Math.PI*2); 
}

ctx.fill();
ctx.shadowBlur = 0; 
}
}

class Particle {
constructor(x, y, color) {
this.x = x; this.y = y; this.color = color;
this.angle = Math.random() * Math.PI * 2;
this.speed = Math.random() * 2 + 0.5;
this.life = 1.0;
}
update() { this.x += Math.cos(this.angle) * this.speed; this.y += Math.sin(this.angle) * this.speed; this.life -= 0.04; }
draw() {
ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
ctx.beginPath(); ctx.arc(this.x, this.y, 2, 0, Math.PI*2); ctx.fill();
ctx.globalAlpha = 1.0;
}
}

class FloatingText {
constructor(text, x, y, color) { this.text = text; this.x = x; this.y = y; this.color = color; this.life = 1.0; }
update() { this.y -= 1; this.life -= 0.02; }
draw() {
ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
ctx.font = "bold 14px Arial"; ctx.fillText(this.text, this.x, this.y);
ctx.globalAlpha = 1.0;
}
}

// --- SYSTEMS ---

function createExplosion(x, y, color, count) {
for(let i=0; i<count; i++) particles.push(new Particle(x, y, color));
}

function addFloatingText(text, x, y, color) {
floatingTexts.push(new FloatingText(text, x, y, color));
}

function spawnLogic() {
let interval = Math.max(60, 180 - (wave * 10));
spawnTimer++;
if (spawnTimer >= interval) {
spawnTimer = 0;

// Tier Logic: Increase potential tiers as waves go up
// Wave 1-2: T0
// Wave 8+: Chance for Queen (T5)

let maxTier = Math.min(Math.floor((wave - 1) / 2), 5); // Allow up to index 5

let roll = Math.random();
let tierIndex = 0;

// QUEEN Spawn Chance (Only after wave 8, and rare)
if (wave >= 8 && roll < 0.05) tierIndex = 5; 
else {
// Standard Logic for other tiers
if (maxTier >= 4 && roll < 0.15) tierIndex = 4; // Red
else if (maxTier >= 3 && roll < 0.25) tierIndex = 3; // Black
else if (maxTier >= 2 && roll < 0.40) tierIndex = 2; // Orange
else if (maxTier >= 1 && roll < 0.60) tierIndex = 1; // Green
else tierIndex = 0; // Blue
}

enemies.push(new Enemy(tierIndex));
}
}

function update() {
if (isGameOver) return;
frame++;
if (frame % 1800 === 0) {
wave++;
updateUI();
addFloatingText("WAVE " + wave, width/2, height/2, '#f0f');
}
spawnLogic();
towers.forEach(t => t.update());
projectiles.forEach((p, index) => { p.update(); if (!p.active) projectiles.splice(index, 1); });
enemies.forEach((e, index) => { e.update(); if (e.hp <= 0) enemies.splice(index, 1); });
particles.forEach((p, index) => { p.update(); if (p.life <= 0) particles.splice(index, 1); });
floatingTexts.forEach((t, index) => { t.update(); if (t.life <= 0) floatingTexts.splice(index, 1); });

if (selectedExistingTower) updateUpgradeMenuLive();
}

function draw() {
ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, width, height);

// Path
ctx.save(); ctx.beginPath();
if(waypoints.length > 0) ctx.moveTo(waypoints[0].x, waypoints[0].y);
for(let i=1; i<waypoints.length; i++) ctx.lineTo(waypoints[i].x, waypoints[i].y);
ctx.lineCap = 'round'; ctx.lineJoin = 'round';
ctx.lineWidth = 30; ctx.strokeStyle = '#181818'; ctx.stroke();
ctx.shadowBlur = 15; ctx.shadowColor = '#222'; ctx.lineWidth = 2; ctx.strokeStyle = '#333'; ctx.stroke();
ctx.restore(); 

towers.forEach(t => t.draw());
enemies.forEach(e => e.draw());
projectiles.forEach(p => p.draw());
particles.forEach(p => p.draw());
floatingTexts.forEach(t => t.draw());

if (pendingTower) drawPendingTowerUI();
}

function drawPendingTowerUI() {
const {x, y, type} = pendingTower;
const stats = TOWER_TYPES[type];

ctx.save(); ctx.beginPath();
ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 2;
ctx.setLineDash([5, 5]); ctx.arc(x, y, stats.range, 0, Math.PI*2); ctx.stroke();
ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; ctx.fill(); ctx.restore();

Tower.drawVisuals(x, y, -Math.PI/2, type, true);
drawButton(x + 40, y - 50, '✓', '#0f0');
drawButton(x - 40, y - 50, '✕', '#f00');
}

function drawButton(bx, by, sym, color) {
ctx.save(); ctx.shadowBlur = 10; ctx.shadowColor = color; ctx.fillStyle = color;
ctx.beginPath(); ctx.arc(bx, by, 20, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#000'; ctx.font = "bold 20px Arial"; ctx.textAlign = "center";
ctx.textBaseline = "middle"; ctx.fillText(sym, bx, by); ctx.restore();
}

function loop() { update(); draw(); requestAnimationFrame(loop); }

// --- INTERACTION ---

function updateUI() {
document.getElementById('stats-money').innerText = `Money: $${money}`;
document.getElementById('stats-wave').innerText = `Wave: ${wave}`;
document.getElementById('stats-lives').innerText = `Lives: ${lives}`;
document.getElementById('high-score-box').innerText = `High Score: ${highScore}`;

['basic', 'sniper', 'tank', 'cannon'].forEach(type => {
let btn = document.getElementById('btn-' + type);
let cost = TOWER_TYPES[type].cost;
if (money >= cost) btn.classList.add('affordable');
else btn.classList.remove('affordable');
if (selectedTowerType === type) btn.classList.add('selected');
else btn.classList.remove('selected');
});

document.getElementById('instruction').style.display = (selectedTowerType && !pendingTower) ? 'block' : 'none';

if (selectedExistingTower) {
document.getElementById('build-menu').style.display = 'none';
document.getElementById('upgrade-menu').style.display = 'flex';
updateUpgradeMenuStatic();
} else {
document.getElementById('build-menu').style.display = 'flex';
document.getElementById('upgrade-menu').style.display = 'none';
}
}

function updateUpgradeMenuStatic() {
if (!selectedExistingTower) return;
const t = selectedExistingTower;
document.getElementById('upg-title').innerText = `${t.stats.name.toUpperCase()} (Lvl ${t.level})`;
const btn = document.getElementById('btn-do-upgrade');
const costSpan = document.getElementById('upg-cost');

if (t.level >= t.stats.maxLevel) {
btn.classList.add('disabled'); btn.onclick = null; costSpan.innerText = "MAX LEVEL";
} else {
costSpan.innerText = `$${t.nextUpgradeCost}`;
if (money >= t.nextUpgradeCost) {
btn.classList.remove('disabled'); btn.onclick = performUpgrade;
} else {
btn.classList.add('disabled'); btn.onclick = null;
}
}
}

function updateUpgradeMenuLive() {
if (!selectedExistingTower) return;
const time = (selectedExistingTower.cooldown / 60).toFixed(1);
document.getElementById('upg-reload').innerText = `${time}s`;
}

window.closeUpgradeMenu = function() { selectedExistingTower = null; updateUI(); }

window.performUpgrade = function() {
if (selectedExistingTower && money >= selectedExistingTower.nextUpgradeCost) {
money -= selectedExistingTower.nextUpgradeCost;
selectedExistingTower.upgrade();
updateUI();
}
}

window.toggleInfo = function() {
const modal = document.getElementById('info-modal');
modal.style.display = (modal.style.display === 'block') ? 'none' : 'block';
}

function checkGameOver() {
if (lives <= 0) {
isGameOver = true;
document.getElementById('final-score').innerText = `You survived ${wave} Waves`;
if (wave > highScore) {
highScore = wave;
localStorage.setItem('neonDefenseHighScore', highScore);
document.getElementById('new-high-score').style.display = 'block';
} else {
document.getElementById('new-high-score').style.display = 'none';
}
document.getElementById('game-over').style.display = 'block';
}
}

window.selectTowerType = function(type) {
if(selectedExistingTower) selectedExistingTower = null; 
if (pendingTower) pendingTower = null; 
if (money >= TOWER_TYPES[type].cost) {
selectedTowerType = (selectedTowerType === type) ? null : type;
updateUI();
}
};

function handleInput(x, y) {
if (pendingTower) {
if (Math.hypot(x - (pendingTower.x + 40), y - (pendingTower.y - 50)) < 30) {
let stats = TOWER_TYPES[pendingTower.type];
if (money >= stats.cost) {
towers.push(new Tower(pendingTower.x, pendingTower.y, pendingTower.type));
money -= stats.cost;
createExplosion(pendingTower.x, pendingTower.y, stats.color, 10);
pendingTower = null; selectedTowerType = null; updateUI();
}
return;
}
if (Math.hypot(x - (pendingTower.x - 40), y - (pendingTower.y - 50)) < 30) {
pendingTower = null; updateUI(); return;
}
let canPlace = true;
towers.forEach(t => { if(Math.hypot(t.x - x, t.y - y) < 30) canPlace = false; });
waypoints.forEach(wp => { if(Math.hypot(wp.x - x, wp.y - y) < 30) canPlace = false; });
if(canPlace) { pendingTower.x = x; pendingTower.y = y; }
return;
} 

let clickedTower = null;
towers.forEach(t => { if (Math.hypot(t.x - x, t.y - y) < 25) clickedTower = t; });
if (clickedTower) {
selectedExistingTower = clickedTower; selectedTowerType = null; updateUI(); return;
} else {
if(selectedExistingTower) { selectedExistingTower = null; updateUI(); return; }
}

if (selectedTowerType) {
let canPlace = true;
towers.forEach(t => { if(Math.hypot(t.x - x, t.y - y) < 30) canPlace = false; });
if (canPlace) { pendingTower = { x: x, y: y, type: selectedTowerType }; updateUI(); }
}
}

canvas.addEventListener('mousedown', (e) => handleInput(e.clientX, e.clientY));
canvas.addEventListener('touchstart', (e) => {
const t = e.touches[0]; handleInput(t.clientX, t.clientY);
}, {passive: false});

window.resetGame = function() {
enemies = []; towers = []; projectiles = []; particles = []; floatingTexts = [];
money = 150; lives = 10; wave = 1; frame = 0; isGameOver = false;
selectedTowerType = null; pendingTower = null; selectedExistingTower = null;
document.getElementById('game-over').style.display = 'none';
updateUI();
};

updateUI(); loop();
</script>
</body>
</html>
